package org.lds.sso.appwrap.proxy;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.URL;
import java.net.URLEncoder;

import javax.mail.internet.MimeUtility;

import org.apache.commons.httpclient.Header;
import org.apache.commons.httpclient.HostConfiguration;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.HttpException;
import org.apache.commons.httpclient.HttpMethod;
import org.apache.commons.httpclient.methods.GetMethod;
import org.lds.sso.appwrap.AppEndPoint;
import org.lds.sso.appwrap.Config;
import org.lds.sso.appwrap.Service;
import org.lds.sso.appwrap.TestUtilities;
import org.lds.sso.appwrap.conditions.evaluator.GlobalHeaderNames;
import org.lds.sso.appwrap.proxy.header.HeaderDef;
import org.testng.Assert;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

public class RequestHandlerIntegrationTest {
    protected static final String MSG4_404_TEST = "don't request this resource. it isn't there.";
    private Service service = null;
    private Thread server = null;
    private ClientSideContext cctx = new ClientSideContext();
    
    private static final String MULTI_BYTE_CHARS_TEXT = "ソフトウェア 建築家 software engineer"; 
    
    private static class ClientSideContext {
    	int sitePort = -1;
    	int serverPort = -1;
    	int freePort = -1;
    }
    
    /**
     * Conveys context into and out of {@link RequestHandlerIntegrationTest.RhIntTest#appliesTo(ServerSideContext)}
     * and {@link RequestHandlerIntegrationTest.RhIntTest#handleServerSide(ServerSideContext)} 
     * methods.
     * 
     * @author BoydMR
     *
     */
    private static class ServerSideContext {
    	
    	/**
    	 * Constructor.
    	 * 
    	 * @param env
    	 * @param envLC
    	 */
    	ServerSideContext(String env, String envLC){
    		this.envelope = env;
    		this.envelopeLC = envLC;
    	}
    	
    	/**
    	 * A string containing the concatenated start line and all headers of 
    	 * the incoming request from which an implementation should be able
    	 * to answer appliesTo().
    	 */
    	String envelope = null;
    	
    	/**
    	 * A lower case version of envelope. 
    	 */
    	String envelopeLC = null;
    	
		/**
		 * mutually exclusive output mechanism available to the test:
		 * 
		 * fullOutputByteSet != null == http response bytes are contained and should be
		 * sent on output stream as-is
		 * 
		 * output != null means full header and body response
		 * characters reside in output variable ready for 
		 * terminating and sending
		 * 
		 * answer != null means only body chars have been
		 * provided via the answer variable and envelope needs to
		 * be generated
		 * 
		 * if all three are null we are hosed
		 */
    	ByteArrayOutputStream fullOutputByteSet = null;
        String output = null;
        String answer = null;
    }
    
    
    /**
     * Encodes multi-byte chars (actually chars above 127) with unicode escaping
     * so that they can be logged.
     * 
     * @param val
     * @return
     */
	public static String getMultiEscaped(String val) {
		StringBuffer asciiSafe = new StringBuffer();
		for(int i=0; i<val.length(); i++) {
			char c = val.charAt(i);
			if (((int)c) > 127) {
				String chars = Integer.toHexString((int)c).toUpperCase();
				
				asciiSafe.append("\\u");
				asciiSafe.append(chars);
			}
			else {
				asciiSafe.append(c);
			}
		}
		return asciiSafe.toString();
	}

	/**
     * Allows for responses that need to have access to the output stream and
     * more control of the output flow. 
     * 
     * @author BoydMR
     *
     */
    private static interface RhIntPlusTest extends RhIntTest{
    	public void handleServerResponse(String envelope, String envelopeLC, OutputStream out);
    }
    
    /**
     * Interface allowing all aspects of an integration test to be co-located. 
     * Includes client side generation of a request to the running instance of 
     * the simulator, simulator routing configuration specific to the test,
     * and potentially the back end server-side handling of the resultant
     * http request made by the simulator.
     *  
     * @author BoydMR
     *
     */
    private static interface RhIntTest {
    	/**
    	 * Indicates if the server-side of the test applies to an http request
    	 * based on envelope of that request in the ServerSideContext.
    	 *  
    	 * @return
    	 */
    	public boolean appliesTo(ServerSideContext ssc);
    	
    	/**
    	 * Provides the serverside handling of http request generated by the 
    	 * runTest method if any.
    	 * 
    	 * @param ctx
    	 */
    	public void handleServerSide(ServerSideContext ssc);
    	
    	/**
    	 * Get the string of xml for cctx-mapping needed by the simulator for
    	 * this test and is unenforced or allow access portions.
    	 * 
    	 * @param serverport
    	 * @param freeport
    	 */
    	public String getSimMappingAndAccess(ClientSideContext csc);
    	
    	/**
    	 * Provides the client-side functionality and assertions of the test.
    	 */
    	public void runTest(ClientSideContext csc) throws Exception;
    }

    /**
     * Empty implementation used for impls that don't contribute server-side
     * functionality since they consume that provided by others.
     * 
     * @author BoydMR
     *
     */
    private static class EmptyRhIntTest implements RhIntTest {
		public boolean appliesTo(ServerSideContext ctx) {
			return false; 
		}

		public void handleServerSide(ServerSideContext ctx) {
		}

		public String getSimMappingAndAccess(ClientSideContext csc) {
			return ""; 
		}

		public void runTest(ClientSideContext csc) throws Exception {
		}
    }
    
    /**
     * The real definition of the set of tests and their behavior.
     * 
     * @author BoydMR
     *
     */
    private enum RhTest {
        /**
         *  @see https://tech.lds.org/jira/browse/WAMULAT-60
         */
    	wamulat_60_test(new RhIntPlusTest() {
			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/wamulat-60/test");
			}
			public void handleServerSide(ServerSideContext ctx) {
				// Response method used instead
			}
			public void handleServerResponse(String envelop, String envelopLC, final OutputStream out) {
				String output = "HTTP/1.1 302 Moved Permanently" + RequestHandler.CRLF
	                    + "Server: test-harness" + RequestHandler.CRLF
	                    + "Location: local.lds.org:9080/some/path" + RequestHandler.CRLF
                    + RequestHandler.CRLF;
				try {
                    System.out.println();
                    System.out.println("--- returned ---");
                    System.out.println(output);
					out.write(output.getBytes());
					out.flush();
					out.close();
				}
				catch(IOException ioe) {
					ioe.printStackTrace();
					return;
				}
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/wamulat-60/test*' thost='127.0.0.1' tport='"
						+ csc.serverPort
						+ "' tpath='/wamulat-60/test*'/>"
						+ "<unenforced cpath='/wamulat-60/test*'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
				Config.getInstance(); // reset configuration
		        System.out.println("----> wamulat_60_test");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/wamulat-60/test/req";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);
		        method.setFollowRedirects(false);
		        long start = System.currentTimeMillis();
		        int status = client.executeMethod(method);
		        Assert.assertEquals(status, 302, "should have returned http 302");
		        Header loc = method.getResponseHeader("location");

		        Assert.assertEquals(loc.getValue(), "local.lds.org:9080/some/path",
		                "redirect location was wrong.");
		        method.releaseConnection();
			}
    	}),
        /**
         *  @see https://tech.lds.org/jira/browse/WAMULAT-56
         */
    	wamulat_56_test(new RhIntPlusTest() {
			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/wamulat-56/test");
			}
			public void handleServerSide(ServerSideContext ctx) {
				// Response method used instead
			}
			public void handleServerResponse(String envelop, String envelopLC, final OutputStream out) {
				String output = "HTTP/1.1 304 Not Modified" + RequestHandler.CRLF
                    + "Server: test-harness" + RequestHandler.CRLF
                    + RequestHandler.CRLF;
				try {
                    System.out.println();
                    System.out.println("--- returned ---");
                    System.out.println(output);
					out.write(output.getBytes());
					out.flush();
                    System.out.println("--- sleeping with stream left open ---");
				}
				catch(IOException ioe) {
					ioe.printStackTrace();
					return;
				}
				Thread slowpoke = new Thread() {

					@Override
					public void run() {
						try {
							Thread.sleep(3000);
							String msg = "<html><body>this should just get dropped.</body></html>";
		                    System.out.println("--- wamulat_56_test awake, slowpoke now returning body ---");
		                    System.out.println(msg);
							out.write(msg.getBytes());
							out.flush();
							out.close();
						} catch (InterruptedException e) {
							System.out.println("slowpoke thread interrupted. Exiting.");
						} catch (IOException e) {
							System.out.println("slowpoke thread incurred exception. " + e.getMessage());
						}
					}
				};
				slowpoke.setDaemon(true);
				slowpoke.start();
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/wamulat-56/test*' thost='127.0.0.1' tport='"
						+ csc.serverPort
						+ "' tpath='/wamulat-56/test*'/>"
						+ "<unenforced cpath='/wamulat-56/test*'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
				Config.getInstance(); // reset configuration
		        System.out.println("----> wamulat_56_test");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/wamulat-56/test/req";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);
		        method.setFollowRedirects(false);
		        long start = System.currentTimeMillis();
		        int status = client.executeMethod(method);
		        long elapsed = System.currentTimeMillis() - start;
		        String resp = method.getResponseBodyAsString();
		        Assert.assertTrue(elapsed < 3000, "shouldn't have waited for close of stream"); 
		        Assert.assertEquals(status, 304, "should have returned http 304 Not Modified");
		        Assert.assertNull(resp, "304 response should NOT have any payload.");
		        method.releaseConnection();
			}
    	}),
        /**
         *  @see https://tech.lds.org/jira/browse/WAMULAT-35
         */
    	wamulat_35_pipe_char_test(new RhIntTest() {

			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/wamulat-35/test/");
			}

			public void handleServerSide(ServerSideContext ctx) {
                int idx = ctx.envelopeLC.indexOf("dude=joe|blah");

                if (idx == -1) {
                    ctx.output =
                        "HTTP/1.1 500 Pipe char didn't pass through" + RequestHandler.CRLF;
                }
                else {
                    ctx.answer = "<html><body>Pipe came through just fine.</body></html>";
                }
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/wamulat-35/*' thost='127.0.0.1' tport='" + csc.serverPort + "' tpath='/wamulat-35/*'/>"
			            + "<unenforced cpath='/wamulat-35/*?*'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> test_wamulat_35_pipe_char_in_url_passes_to_app ");

		        Socket sock = new Socket("127.0.0.1", csc.sitePort);
		        sock.setSoTimeout(400000); // make sure we have a long timeout
		        
		        // send request
		        // url = http://local.lds.org:<sitePort>/wamulat-35/test/?dude=joe|blah;
		        OutputStream out = sock.getOutputStream();
		        out.write(("GET /wamulat-35/test/?dude=joe|blah Http/1.1" 
		                + RequestHandler.CRLF).getBytes());
		        out.write(("Host: local.lds.org:" + csc.sitePort 
		                + RequestHandler.CRLF + RequestHandler.CRLF).getBytes());
		        out.flush();

		        // read response
		        InputStream in = sock.getInputStream();
		        byte[] bytes = new byte[4096];
		        int read = in.read(bytes);
		        in.close();
		        out.close();
		        sock.close();
		        
		        String http = new String(bytes, 0, read);
		        Assert.assertTrue(http.startsWith("HTTP/1.1 "), "Should start with 'HTTP/1.1 '");
		        int idx = http.indexOf(" ", "HTTP/1.1 ".length());
		        Assert.assertTrue(idx != -1, "Should contain response code followed by space");
		        String sCode = http.substring("HTTP/1.1 ".length(), idx);
		        int code = Integer.parseInt(sCode);
		        Assert.assertEquals(code, 200, "should have returned http 200 OK");
			}
    	}),
        /**
         *  @see https://tech.lds.org/jira/browse/WAMULAT-35
         */
    	wamulat_35_pipe_char_absltReqLn_test(new EmptyRhIntTest() {
    		// note that server-side behavior is handled in wamulat_35_pipe_char_test
			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> test_wamulat_35_pipe_char_in_full_reqLnUrl_passes_to_app ");

		        Socket sock = new Socket("127.0.0.1", csc.sitePort);
		        sock.setSoTimeout(400000); // make sure we have a long timeout
		        
		        // send request
		        // url = http://local.lds.org:<sitePort>/wamulat-35/test/?dude=joe|blah;
		        OutputStream out = sock.getOutputStream();
		        out.write(("GET http://local.lds.org:" + csc.sitePort + "/wamulat-35/test/?dude=joe|blah Http/1.1" 
		                + RequestHandler.CRLF + RequestHandler.CRLF).getBytes());
		        out.flush();

		        // read response
		        InputStream in = sock.getInputStream();
		        byte[] bytes = new byte[4096];
		        int read = in.read(bytes);
		        in.close();
		        out.close();
		        sock.close();
		        
		        String http = new String(bytes, 0, read);
		        Assert.assertTrue(http.startsWith("HTTP/1.1 "), "Should start with 'HTTP/1.1 '");
		        int idx = http.indexOf(" ", "HTTP/1.1 ".length());
		        Assert.assertTrue(idx != -1, "Should contain response code followed by space");
		        String sCode = http.substring("HTTP/1.1 ".length(), idx);
		        int code = Integer.parseInt(sCode);
		        Assert.assertEquals(code, 200, "should have returned http 200 OK");
			}
    	}),
    	preserve_host_test(new RhIntTest() {

			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/preserve/host/test/");
			}

			public void handleServerSide(ServerSideContext ctx) {
				
                ctx.answer = HeaderDef.Host.getNameWithColon() + " ???";
                String hstHdrKey = RequestHandler.CRLF + HeaderDef.Host.getLcNameWithColon();
                int idx = ctx.envelopeLC.indexOf(hstHdrKey);

                if (idx != -1) {
                    int cr = ctx.envelope.indexOf(RequestHandler.CRLF, idx+1);
                    String val = null;
                    if (cr == -1) {
                        // last header
                        val = ctx.envelope.substring(idx+hstHdrKey.length()).trim();
                    }
                    else {
                        val = ctx.envelope.substring(idx+hstHdrKey.length(), cr).trim();
                    }
                    ctx.answer = HeaderDef.Host.getNameWithColon() + " " + val;
                }
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/preserve/*' thost='127.0.0.1' tport='" + csc.serverPort + "' tpath='/preserve/*' preserve-host='true'/>"
			            + "<unenforced cpath='/preserve/*'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> test_preserve_host ");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/preserve/host/test/";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);

		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String response = method.getResponseBodyAsString().trim();
		        Assert.assertEquals(status, 200, "should have returned http 200 OK");
		        Assert.assertEquals(response, HeaderDef.Host.getNameWithColon() + " local.lds.org:" + csc.sitePort);
		        method.releaseConnection();
			}
    	}),
    	verify_cctx_injected_test(new RhIntTest() {

			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/verify/cctx/injected/test/");
			}

			public void handleServerSide(ServerSideContext ctx) {
				
                ctx.answer = HeaderDef.Host.getNameWithColon() + " ???";
                String hstHdrKey = RequestHandler.CRLF + AppEndPoint.CCTX_HEADER + ":";
                int idx = ctx.envelopeLC.indexOf(hstHdrKey);

                if (idx != -1) {
                    int cr = ctx.envelope.indexOf(RequestHandler.CRLF, idx+1);
                    String val = null;
                    if (cr == -1) {
                        // last header
                        val = ctx.envelope.substring(idx+hstHdrKey.length()).trim();
                    }
                    else {
                        val = ctx.envelope.substring(idx+hstHdrKey.length(), cr).trim();
                    }
                    ctx.answer = AppEndPoint.CCTX_HEADER + ": " + val;
                }
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/verify/cctx/injected/*' thost='127.0.0.1' tport='" + csc.serverPort + "' tpath='/verify/cctx/injected/*'/>"
			            + "<unenforced cpath='/verify/cctx/injected/*'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> test_verify_cctx_injected ");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/verify/cctx/injected/test/";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);

		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String response = method.getResponseBodyAsString().trim();
		        Assert.assertEquals(status, 200, "should have returned http 200 OK");
		        Assert.assertEquals(response, AppEndPoint.CCTX_HEADER + ":" + " /verify/cctx/injected/{/.../*,*}");
		        method.releaseConnection();
			}
    	}),
    	verify_serviceUrl_signIn_signOut_injected(new RhIntTest() {

			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/verify/required-headers/injected");
			}

			public void handleServerSide(ServerSideContext ctx) {
				ctx.answer = "";
				this.lookForHdr(ctx, GlobalHeaderNames.SERVICE_URL);
				this.lookForHdr(ctx, GlobalHeaderNames.SIGNIN);
				this.lookForHdr(ctx, GlobalHeaderNames.SIGNOUT);
			}
			
			private void lookForHdr(ServerSideContext ctx, String hdr) {
                int idx = ctx.envelopeLC.indexOf(hdr);

                if (idx != -1) {
                    int cr = ctx.envelope.indexOf(RequestHandler.CRLF, idx+1);
                    String val = null;
                    if (cr == -1) {
                        // last header
                        val = ctx.envelope.substring(idx+hdr.length()).trim();
                    }
                    else {
                        val = ctx.envelope.substring(idx+hdr.length(), cr).trim();
                    }
                    ctx.answer += hdr + "=" + val + RequestHandler.CRLF;
                }
                else {
                    ctx.answer += hdr + "--NOT FOUND" + RequestHandler.CRLF;
                }
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/verify/required-headers/injected*' thost='127.0.0.1' tport='" + csc.serverPort + "' tpath='/verify/required-headers/injected*' preserve-host='true'/>"
			            + "<unenforced cpath='/verify/required-headers/injected*'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> test_verify_serviceUrl_signIn_signOut_injected ");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/verify/required-headers/injected";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);

		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String response = method.getResponseBodyAsString().trim();
		        System.out.println("--response from server: " + response);
		        Assert.assertFalse(response.contains(GlobalHeaderNames.SERVICE_URL + "--NOT FOUND"));
		        Assert.assertFalse(response.contains(GlobalHeaderNames.SIGNIN + "--NOT FOUND"));
		        Assert.assertFalse(response.contains(GlobalHeaderNames.SIGNOUT + "--NOT FOUND"));
		        method.releaseConnection();
			}
    	}),
    	no_preserve_host_test(new RhIntTest() {

			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/no-preserve/host/test/");
			}

			public void handleServerSide(ServerSideContext ctx) {
				ctx.answer = HeaderDef.Host.getNameWithColon() + " ???";
                String hstHdrKey = RequestHandler.CRLF + HeaderDef.Host.getLcNameWithColon();
                int idx = ctx.envelopeLC.indexOf(hstHdrKey);

                    if (idx != -1) {
                        int cr = ctx.envelope.indexOf(RequestHandler.CRLF, idx+1);
                        String val = null;
                        if (cr == -1) {
                            // last header
                            val = ctx.envelope.substring(idx+hstHdrKey.length()).trim();
                        }
                        else {
                            val = ctx.envelope.substring(idx+hstHdrKey.length(), cr).trim();
                        }
                        ctx.answer = HeaderDef.Host.getNameWithColon() + " " + val;
                    }
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/no-preserve/*' thost='127.0.0.1' tport='" 
						+ csc.serverPort + "' tpath='/no-preserve/*' preserve-host='false'/>"
			            + "<unenforced cpath='/no-preserve/*'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> test_dont_preserve_host ");
		        String uri = "http://local2.lds.org:" + csc.sitePort + "/no-preserve/host/test/";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);

		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String response = method.getResponseBodyAsString().trim();
		        Assert.assertEquals(status, 200, "should have returned http 200 OK");
		        Assert.assertEquals(response, HeaderDef.Host.getNameWithColon() + " 127.0.0.1:" + csc.serverPort);
		        method.releaseConnection();
			}
    	}),
    	host_header_test(new RhIntTest() {

			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/host-header/test/");
			}

			public void handleServerSide(ServerSideContext ctx) {
				ctx.answer = HeaderDef.Host.getNameWithColon() + " ???";
                String hstHdrKey = RequestHandler.CRLF + HeaderDef.Host.getLcNameWithColon();
                int idx = ctx.envelopeLC.indexOf(hstHdrKey);

                if (idx != -1) {
                    int cr = ctx.envelope.indexOf(RequestHandler.CRLF, idx+1);
                    String val = null;
                    if (cr == -1) {
                        // last header
                        val = ctx.envelope.substring(idx+hstHdrKey.length()).trim();
                    }
                    else {
                        val = ctx.envelope.substring(idx+hstHdrKey.length(), cr).trim();
                    }
                    ctx.answer = HeaderDef.Host.getNameWithColon() + " " + val;
                }
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/host-header/*' thost='127.0.0.1' tport='"
						+ csc.serverPort
						+ "' tpath='/host-header/*' host-header='host.lds.org:2445'/>"
						+ "<unenforced cpath='/host-header/*'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> test_host_header ");
		        String uri = "http://local3.lds.org:" + csc.sitePort + "/host-header/test/";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);

		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String response = method.getResponseBodyAsString().trim();
		        Assert.assertEquals(status, 200, "should have returned http 200 OK");
		        Assert.assertEquals(response, HeaderDef.Host.getNameWithColon() + " host.lds.org:2445");
		        method.releaseConnection();
			}
    	}),
    	profile_header_injection_test(new RhIntTest() {
			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/profile-att/header/test/");
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/profile-att/header/*' thost='127.0.0.1' tport='"
						+ csc.serverPort
						+ "' tpath='/profile-att/header/*'>"
						+ " <headers>"
			            + "  <profile-att name='prof-1' attribute='att-1'/>"
			            + "  <profile-att name='prof-2' attribute='att-2'/>"
						+ " </headers>"
						+ "</cctx-mapping>"
						+ "<allow action='GET' cpath='/profile-att/header/*'/>";
			}

			public void handleServerSide(ServerSideContext ctx) {
				// when finished .answer should be "prof-vals: prof-1=val1; prof-2=val2-1,val2-2"
            	ctx.answer = "prof-vals: ";

            	// check prof-1 first and inject into response
                String sHdr = RequestHandler.CRLF + "prof-1:";
                int sIdx = ctx.envelopeLC.indexOf(sHdr);

                if (sIdx != -1) {
                    int cr = ctx.envelope.indexOf(RequestHandler.CRLF, sIdx+1);
                    String val = null;
                    if (cr == -1) {
                        // last header
                        val = ctx.envelope.substring(sIdx+sHdr.length()).trim();
                    }
                    else {
                        val = ctx.envelope.substring(sIdx+sHdr.length(), cr).trim();
                    }
                    ctx.answer += "prof-1=" + val;
                }
                
            	// check first of multi & inject into response
                String mHdr = RequestHandler.CRLF + "prof-2:";
                int mIdx = ctx.envelopeLC.indexOf(mHdr);

                if (mIdx != -1) {
                    int cr = ctx.envelope.indexOf(RequestHandler.CRLF, mIdx+1);
                    String val = null;
                    if (cr == -1) {
                        // last header
                        val = ctx.envelope.substring(mIdx+mHdr.length()).trim();
                    }
                    else {
                        val = ctx.envelope.substring(mIdx+mHdr.length(), cr).trim();
                    }
                    ctx.answer += "; prof-2=" + val;
                }

            	// check second of multi & inject into response
                int m2Idx = ctx.envelopeLC.indexOf(mHdr, mIdx+1);

                if (m2Idx != -1) {
                    int cr = ctx.envelope.indexOf(RequestHandler.CRLF, m2Idx+1);
                    String val = null;
                    if (cr == -1) {
                        // last header
                        val = ctx.envelope.substring(m2Idx+mHdr.length()).trim();
                    }
                    else {
                        val = ctx.envelope.substring(m2Idx+mHdr.length(), cr).trim();
                    }
                    ctx.answer += "," + val;
                }
			}

			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> profile_header_injection_test ");
		        
		        // only verify for authenticated user
		        String uri = "http://local.lds.org:" + csc.sitePort + "/profile-att/header/test/";
		        Config cfg = Config.getInstance();
		        String token = TestUtilities.authenticateUser("ngiwb2", cfg.getConsolePort(), "local.lds.org");
		        System.out.println(" auth'd ngiwb2");

		        HttpClient client2 = new HttpClient();

		        HostConfiguration hcfg2 = new HostConfiguration();
		        hcfg2.setProxy("127.0.0.1", csc.sitePort);
		        client2.setHostConfiguration(hcfg2);

		        HttpMethod method2 = new GetMethod(uri);
		        method2.setRequestHeader(new Header("cookie", cfg.getCookieName() + "=" + token));
		        method2.setFollowRedirects(false);

		        int status2 = client2.executeMethod(method2);
		        String response2 = method2.getResponseBodyAsString().trim();
		        Assert.assertEquals(status2, 200, "should have returned http 200 OK");
		        Assert.assertEquals(response2, "prof-vals: prof-1=val1; prof-2=val2-1,val2-2");
		        method2.releaseConnection();
			}
    	}),
    	fixed_header_injection_test(new RhIntTest() {
			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/fixed-value/header/test/");
			}

			public void handleServerSide(ServerSideContext ctx) {
				// when finished .answer should be "fixed-vals: single=single-1; multi=multi-1,multi-2"
            	ctx.answer = "fixed-vals: ";

            	// check single first and inject into response
                String sHdr = RequestHandler.CRLF + "single:";
                int sIdx = ctx.envelopeLC.indexOf(sHdr);

                if (sIdx != -1) {
                    int cr = ctx.envelope.indexOf(RequestHandler.CRLF, sIdx+1);
                    String val = null;
                    if (cr == -1) {
                        // last header
                        val = ctx.envelope.substring(sIdx+sHdr.length()).trim();
                    }
                    else {
                        val = ctx.envelope.substring(sIdx+sHdr.length(), cr).trim();
                    }
                    ctx.answer += "single=" + val;
                }
                
            	// check first of multi & inject into response
                String mHdr = RequestHandler.CRLF + "multi:";
                int mIdx = ctx.envelopeLC.indexOf(mHdr);

                if (mIdx != -1) {
                    int cr = ctx.envelope.indexOf(RequestHandler.CRLF, mIdx+1);
                    String val = null;
                    if (cr == -1) {
                        // last header
                        val = ctx.envelope.substring(mIdx+mHdr.length()).trim();
                    }
                    else {
                        val = ctx.envelope.substring(mIdx+mHdr.length(), cr).trim();
                    }
                    ctx.answer += "; multi=" + val;
                }

            	// check second of multi & inject into response
                int m2Idx = ctx.envelopeLC.indexOf(mHdr, mIdx+1);

                if (m2Idx != -1) {
                    int cr = ctx.envelope.indexOf(RequestHandler.CRLF, m2Idx+1);
                    String val = null;
                    if (cr == -1) {
                        // last header
                        val = ctx.envelope.substring(m2Idx+mHdr.length()).trim();
                    }
                    else {
                        val = ctx.envelope.substring(m2Idx+mHdr.length(), cr).trim();
                    }
                    ctx.answer += "," + val;
                }
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/fixed-value/header/*' thost='127.0.0.1' tport='"
						+ csc.serverPort
						+ "' tpath='/fixed-value/header/*'>"
						+ " <headers>"
						+ "  <fixed-value name='single' value='single-1'/>"
						+ "  <fixed-value name='multi' value='multi-1'/>"
						+ "  <fixed-value name='multi' value='multi-2'/>"
						+ " </headers>"
						+ "</cctx-mapping>"
						+ "<unenforced cpath='/fixed-value/header/*'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> fixed_header_injection_test ");
		        
		        // first verify for UN-authenticated user
		        String uri = "http://local.lds.org:" + csc.sitePort + "/fixed-value/header/test/";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);
		        method.setFollowRedirects(false);

		        int status = client.executeMethod(method);
		        String response = method.getResponseBodyAsString().trim();
		        Assert.assertEquals(status, 200, "should have returned http 200 OK");
		        Assert.assertEquals(response, "fixed-vals: single=single-1; multi=multi-1,multi-2");
		        method.releaseConnection();

		        // now verify for authenticated user
		        Config cfg = Config.getInstance();
		        String token = TestUtilities.authenticateUser("ngiwb2", cfg.getConsolePort(), "local.lds.org");
		        System.out.println(" auth'd ngiwb2");

		        HttpClient client2 = new HttpClient();

		        HostConfiguration hcfg2 = new HostConfiguration();
		        hcfg2.setProxy("127.0.0.1", csc.sitePort);
		        client2.setHostConfiguration(hcfg2);

		        HttpMethod method2 = new GetMethod(uri);
		        method2.setRequestHeader(new Header("cookie", cfg.getCookieName() + "=" + token));
		        method2.setFollowRedirects(false);

		        int status2 = client2.executeMethod(method2);
		        String response2 = method2.getResponseBodyAsString().trim();
		        Assert.assertEquals(status2, 200, "should have returned http 200 OK");
		        Assert.assertEquals(response2, "fixed-vals: single=single-1; multi=multi-1,multi-2");
		        method2.releaseConnection();
			}
    	}),
    	wamulat_48_test(new RhIntTest() {
			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/wamulat-48/rfc2047/test/");
			}

			public void handleServerSide(ServerSideContext ctx) {
            	ctx.answer = "preferredname: ???";
                String hdrKey = RequestHandler.CRLF + "preferredname:";
                int idx = ctx.envelopeLC.indexOf(hdrKey);

                if (idx != -1) {
                    int cr = ctx.envelope.indexOf(RequestHandler.CRLF, idx+1);
                    String val = null;
                    if (cr == -1) {
                        // last header
                        val = ctx.envelope.substring(idx+hdrKey.length()).trim();
                    }
                    else {
                        val = ctx.envelope.substring(idx+hdrKey.length(), cr).trim();
                    }
                    String decd = null;
                    boolean matched = false;
                    try {
                    	decd = MimeUtility.decodeText(val);
                    	if (decd.equals(MULTI_BYTE_CHARS_TEXT)) {
                    		matched = true;
                    	}
                    	else {
                    		String logMsg = "Expected '" + MULTI_BYTE_CHARS_TEXT + "' but decoding header value '" + val + "' resulted in '" + decd + "'";
                    		System.out.println(getMultiEscaped(logMsg));
                    	}
					}
					catch (UnsupportedEncodingException e) {
						e.printStackTrace();
					}
                    ctx.answer = "preferredname matched: " + matched;
                    }
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/wamulat-48/*' thost='127.0.0.1' tport='"
						+ csc.serverPort + "' tpath='/wamulat-48/*'>"
						+ " <headers>"
						+ "  <profile-att name='preferredname' attribute='preferredname'/>"
						+ " </headers>"
						+ "</cctx-mapping>"
						+ "<unenforced cpath='/wamulat-48/*'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> test_wamulat_48 ");
		        
		        Config cfg = Config.getInstance();
		        String token = TestUtilities.authenticateUser("ngiwb2", cfg.getConsolePort(), "local.lds.org");
		        System.out.println(" auth'd ngiwb2");

		        String uri = "http://local.lds.org:" + csc.sitePort + "/wamulat-48/rfc2047/test/";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);
		        
		        HttpMethod method = new GetMethod(uri);
		        method.setRequestHeader(new Header("cookie", cfg.getCookieName() + "=" + token));
		        method.setFollowRedirects(false);
		        System.out.println("Injecting client header value of '" 
		        		+ RequestHandlerIntegrationTest.getMultiEscaped(MULTI_BYTE_CHARS_TEXT) + "'");
		        String val = MULTI_BYTE_CHARS_TEXT;
				try {
                    val = MimeUtility.encodeText(val, "utf-8", null);
    		        System.out.println("After MimeEncoding was '" + val + "'");
    		        method.setRequestHeader("client-injected-multi-byte", val);
                } catch (UnsupportedEncodingException e) {
                    e.printStackTrace();
                }
				
				// try encoding with james encoder

		        int status = client.executeMethod(method);
		        String response = method.getResponseBodyAsString().trim();
		        Assert.assertEquals(status, 200, "should have returned http 200 OK");
		        Assert.assertEquals(response, "preferredname matched: true");
		        method.releaseConnection();
			}
    	}),
    	restricted_test(new RhIntTest() {
			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/restricted/test/");
			}

			public void handleServerSide(ServerSideContext ctx) {
	            ctx.answer = "You made it";
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/restricted/*' thost='127.0.0.1' tport='"
						+ csc.serverPort
						+ "' tpath='/restricted/*' preserve-host='false'/>"
						+ "   <allow action='GET' cpath='/restricted/*'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
		        Config cfg = Config.getInstance();
		        String token = TestUtilities.authenticateUser("ngiwb1", cfg.getConsolePort(), "local.lds.org");
		        System.out.println("----> test_restricted_with_good_session_proxied");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/restricted/test/";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);
		        method.setRequestHeader(new Header("cookie", cfg.getCookieName() + "=" + token));
		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        Assert.assertEquals(status, 200, "should have returned http 200");
		        String content = method.getResponseBodyAsString();
		        Assert.assertEquals(content, "You made it", "wrong content returned.");
		        method.releaseConnection();
			}
    	}),
    	restricted_test_redird(new EmptyRhIntTest() {
    		// config and server-side provided by restricted_test
			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> test_restricted_with_no_session_redir_2_signin");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/restricted/path/";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);

		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        Assert.assertEquals(status, 302, "should have returned http 302");
		        Header loc = method.getResponseHeader("location");

		        Assert.assertEquals(loc.getValue(), Config.getInstance().getLoginPage()
		                + "?goto=" + URLEncoder.encode(uri, "utf-8"),
		                "redirect location was wrong.");
		        method.releaseConnection();
			}
    	}),
    	conditional_test(new RhIntTest() {
			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/conditional/test/");
			}

			public void handleServerSide(ServerSideContext ctx) {
	            ctx.answer = "You made it";
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/conditional/*' thost='127.0.0.1' tport='"
						+ csc.serverPort
						+ "' tpath='/conditional/*' preserve-host='false'/>"
						+ "<allow action='GET' cpath='/conditional/*' condition='{{app-bbb}}'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
		        Config cfg = Config.getInstance();
		        String token = TestUtilities.authenticateUser("ngiwb1", cfg.getConsolePort(), "local.lds.org");
		        System.out.println("----> test_restricted_with_good_session_not_cond_403");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/conditional/test/";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);
		        method.setRequestHeader(new Header("cookie", cfg.getCookieName() + "=" + token));
		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String resp = method.getResponseBodyAsString();
		        if (status != 403 && resp != null) {
		            System.out.println(resp);
		        }
		        Assert.assertEquals(status, 403, "should have returned http 403");
		        method.releaseConnection();
			}
    	}),
    	bad_gateway_message(new RhIntTest() {
			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/bad/gateway/message");
			}

			public void handleServerSide(ServerSideContext ctx) {
                // simulates a message that looks like a request.
                // shouldn't ever happen but testing since processing
                // of reqs and resps uses the same getHttpPackage method.
				ctx.output = "GET /bad/gateway/message/ HTTP/1.1" + RequestHandler.CRLF + RequestHandler.CRLF;
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/bad/gateway/message*' thost='127.0.0.1' tport='"
						+ csc.serverPort
						+ "' tpath='/bad/gateway/message*'/>"
						+ "<unenforced cpath='/bad/gateway/*'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
		        Config.getInstance();
		        System.out.println("----> test_bad_gateway_message");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/bad/gateway/message";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);
		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String resp = method.getResponseBodyAsString();
		        if (status != 502 && resp != null) {
		            System.out.println(resp);
		        }
		        Assert.assertEquals(status, 502, "should have returned http 502 bad gateway");
		        method.releaseConnection();
			}
    	}),
    	bad_gateway_message_conn(new EmptyRhIntTest() {
    		// test has no server side since connects to port without listener
			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/bad/gateway/test*' thost='127.0.0.1' tport='"
						+ csc.freePort + "' tpath='/bad/gateway/test*'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
		        Config.getInstance();
		        System.out.println("----> test_bad_gateway_when_connecting");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/bad/gateway/test";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);
		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String resp = method.getResponseBodyAsString();
		        if (status != 502 && resp != null) {
		            System.out.println(resp);
		        }
		        Assert.assertEquals(status, 502, "should have returned http 502 bad gateway");
		        method.releaseConnection();
			}
    	}),
    	bad_gateway_empty_message(new RhIntTest() {
			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/bad/gateway/empty/msg");
			}

			public void handleServerSide(ServerSideContext ctx) {
	            ctx.output = RequestHandler.CRLF + RequestHandler.CRLF + RequestHandler.CRLF;
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/bad/gateway/empty/*' thost='127.0.0.1' tport='"
						+ csc.serverPort + "' tpath='/bad/gateway/empty/*'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
		        Config.getInstance();
		        System.out.println("----> test_bad_gateway_empty_message");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/bad/gateway/empty/msg";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);
		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String resp = method.getResponseBodyAsString();
		        if (status != 502 && resp != null) {
		            System.out.println(resp);
		        }
		        Assert.assertEquals(status, 502, "should have returned http 502 bad gateway");
		        method.releaseConnection();
			}
    	}),
    	bad_startline_message(new RhIntTest() {
			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/bad/response/startline");
			}

			public void handleServerSide(ServerSideContext ctx) {
				ctx.output = "HTTP/1.1404NotFound" + RequestHandler.CRLF + RequestHandler.CRLF;
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/bad/response/startline*' thost='127.0.0.1' tport='"
						+ csc.serverPort
						+ "' tpath='/bad/response/startline*'/>"
						+ "<unenforced cpath='/bad/response/startline*'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
		        Config.getInstance();
		        System.out.println("----> test_bad_response_startline_no_space");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/bad/response/startline/test";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);
		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String resp = method.getResponseBodyAsString();
		        if (status != 502 && resp != null) {
		            System.out.println(resp);
		        }
		        Assert.assertEquals(status, 502, "should have returned http 502 bad gateway");
		        method.releaseConnection();
			}
    	}),
    	bad_request_startline_no_space(new EmptyRhIntTest() {
	        // note: we don't need to include simulator config since this bad 
    		// request fails during parsing due to bad startline
	        // won't make it to the enforcement point in RequestHandler.java.

			public void runTest(ClientSideContext csc) throws Exception {
		        Config.getInstance();
		        System.out.println("----> test_bad_request_startline_no_space");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/bad/request/startline/test";
		        Socket sock = new Socket("127.0.0.1", csc.sitePort);
		        sock.setSoTimeout(400000); // make sure we have a long timeout
		        OutputStream out = sock.getOutputStream();
		        out.write(("GET/some/unexistent/pathHttp/1.1" 
		                + RequestHandler.CRLF + RequestHandler.CRLF).getBytes());
		        out.flush();
		        InputStream in = sock.getInputStream();
		        byte[] bytes = new byte[4096];
		        int read = in.read(bytes);
		        out.close();
		        in.close();
		        sock.close();
		        
		        String http = new String(bytes, 0, "http/1.1 ".length());
		        Assert.assertEquals(http.toLowerCase(), "http/1.1 ");
			}
    	}),
    	resp_code_404_test_wcl(new RhIntTest() {
			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/404/test-wcl");
			}
			public void handleServerSide(ServerSideContext ctx) {
                // test to verify that html content for 404 and 500 level
                // response codes makes it through to the browser.
                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                String html = "<html><head>\r\n" 
                    + "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\"/>\r\n" 
                    + "<title>Error 404 NOT_FOUND</title>\r\n" 
                    + "</head>\r\n" 
                    + "<body><h2>HTTP ERROR: 404</h2><pre>NOT_FOUND</pre>\r\n" 
                    + "<p>" + MSG4_404_TEST + " </p>\r\n" 
                    + "<p><i><small>we really mean it.</small></i></p>\r\n" 
                    + "<br/></body></html>";
                try {
					baos.write(html.getBytes());
				} catch (IOException e) {
					// won't happent
					e.printStackTrace();
				}
                ctx.output = "HTTP/1.1 404 Not Found" + RequestHandler.CRLF
                    + "Content-Type: text/html; charset=iso-8859-1" + RequestHandler.CRLF
                    + "Server: test-harness" + RequestHandler.CRLF
                    + "Content-Length: " + baos.size()
                    + RequestHandler.CRLF + RequestHandler.CRLF
                    + new String(baos.toByteArray());
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<cctx-mapping cctx='/404/test-*' thost='127.0.0.1' tport='" + csc.serverPort + "' tpath='/404/test-*'/>"
			            + "<unenforced cpath='/404/test-*'/>";
			}

			public void runTest(ClientSideContext csc) throws Exception {
				Config.getInstance(); // reset configuration
		        System.out.println("----> test_404_payload_is_passed_through");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/404/test-wcl/req";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);
		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String resp = method.getResponseBodyAsString();
		        if (resp != null) {
		            System.out.println(resp);
		        }
		        Assert.assertEquals(status, 404, "should have returned http 404 not found");
		        Assert.assertNotNull(resp, "404 response payload should have been passed-through.");
		        Assert.assertTrue(resp.contains(MSG4_404_TEST), "page content should have contained: " + MSG4_404_TEST);
		        method.releaseConnection();
			}
    	}),
    	resp_code_404_test_ncl(new RhIntTest() {
			public boolean appliesTo(ServerSideContext ctx) {
				return ctx.envelope.contains("/404/test-ncl");
			}
			public void handleServerSide(ServerSideContext ctx) {
                // test to verify that html content for 404 and 500 level
                // response codes makes it through to the browser
                // even when no content-length response header is
                // included.
                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                String html = "<html><head>\r\n" 
                    + "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\"/>\r\n" 
                    + "<title>Error 404 NOT_FOUND</title>\r\n" 
                    + "</head>\r\n" 
                    + "<body><h2>HTTP ERROR: 404</h2><pre>NOT_FOUND</pre>\r\n" 
                    + "<p>" + MSG4_404_TEST + " </p>\r\n" 
                    + "<p><i><small>we really mean it.</small></i></p>\r\n" 
                    + "<br/></body></html>";
                try {
					baos.write(html.getBytes());
				} catch (IOException e) {
					// should never happen with baos
					e.printStackTrace();
				}
                ctx.output = "HTTP/1.1 404 Not Found" + RequestHandler.CRLF
                    + "Content-Type: text/html; charset=iso-8859-1" + RequestHandler.CRLF
                    + "Server: test-harness"
                    + RequestHandler.CRLF + RequestHandler.CRLF
                    + new String(baos.toByteArray());
			}

			public String getSimMappingAndAccess(ClientSideContext csc) {
				return ""; // uses config for resp_code_404_test_wcl
			}

			public void runTest(ClientSideContext csc) throws Exception {

		        Config cfg = Config.getInstance();
		        System.out.println("----> test_404_payload_is_passed_through");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/404/test-ncl/req";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);
		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String resp = method.getResponseBodyAsString();
		        if (resp != null) {
		            System.out.println(resp);
		        }
		        Assert.assertEquals(status, 404, "should have returned http 404 not found");
		        Assert.assertNotNull(resp, "404 response payload should have been passed-through.");
		        Assert.assertTrue(resp.contains(MSG4_404_TEST), "page content should have contained: " + MSG4_404_TEST);
		        method.releaseConnection();
			}
    	}),
    	set_up_sim_access_for_file_tests(new EmptyRhIntTest() {
			public String getSimMappingAndAccess(ClientSideContext csc) {
				return "<unenforced cpath='/file/*'/>";
			}
    	}),
    	test_local_relative_file_mapping(new EmptyRhIntTest() {
			public String getSimMappingAndAccess(ClientSideContext csc) {
				// is dependent on set_up_sim_access_for_file_tests
				return "<cctx-file cctx='/file/local/relative/*' file='*' content-type='text/plain'/>";
			}
			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> test_local_relative_file_mapping");
		        // first make sure that we have a sample file
		        File file = new File("sample-output2.txt");
		        if (file.exists()) {
		            file.delete();
		        }
		        FileOutputStream fos = new FileOutputStream("sample-output2.txt");
		        fos.write("---Sample Local File Serving 2---".getBytes());
		        fos.flush();
		        fos.close();

		        // now serve it up
		        String uri = "http://local.lds.org:" + csc.sitePort + "/file/local/relative/sample-output2.txt";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);

		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String response = method.getResponseBodyAsString().trim();
		        Assert.assertEquals(status, 200, "should have returned http 200 OK");
		        Header type = method.getResponseHeader("content-type");
		        Assert.assertEquals(type.getValue(), "text/plain", "type should be text/plain as defined in the mapping");
		        Assert.assertTrue(response.contains("Sample Local File Serving 2"), "Content of response should contain 'Sample Local File Serving 2' from auto-generated file sample-output2.txt");
		        method.releaseConnection();
			}
    	}),
    	test_local_fixed_file_mapping(new EmptyRhIntTest() {
			public String getSimMappingAndAccess(ClientSideContext csc) {
				// is dependent on set_up_sim_access_for_file_tests
				return "<cctx-file cctx='/file/local/fixed*' file='sample-output.txt' content-type='text/plain'/>";
			}
			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> test_local_fixed_file_mapping");
		        // first make sure that we have a sample file
		        File file = new File("sample-output.txt");
		        if (file.exists()) {
		            file.delete();
		        }
		        FileOutputStream fos = new FileOutputStream("sample-output.txt");
		        fos.write("---Sample Local File Serving---".getBytes());
		        fos.flush();
		        fos.close();

		        // now serve it up
		        String uri = "http://local.lds.org:" + csc.sitePort + "/file/local/fixed/any-name-gets-same-content.html";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);

		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String response = method.getResponseBodyAsString().trim();
		        Assert.assertEquals(status, 200, "should have returned http 200 OK");
		        Header type = method.getResponseHeader("content-type");
		        Assert.assertEquals(type.getValue(), "text/plain", "type should be text/plain as defined in the mapping");
		        Assert.assertTrue(response.contains("Sample Local File Serving"), "Content of response should contain 'Sample Local File Serving' from auto-generated file sample-output.txt");
		        method.releaseConnection();
			}
    	}),
    	test_fixed_classpath_file_mapping(new EmptyRhIntTest() {
			public String getSimMappingAndAccess(ClientSideContext csc) {
				// is dependent on set_up_sim_access_for_file_tests
				return "<cctx-file cctx='/file/cp/fixed/*' file='classpath:RequestHandlerIntegrationTestFile1.txt' content-type='text/html'/>";
			}
			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> test_fixed_classpath_file_mapping");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/file/cp/fixed/any-name-gets-same-content.html";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);

		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String response = method.getResponseBodyAsString().trim();
		        Assert.assertEquals(status, 200, "should have returned http 200 OK");
		        Header type = method.getResponseHeader("content-type");
		        Assert.assertEquals(type.getValue(), "text/html", "type should be text/html as defined in the mapping even though the extension of the file indicates just plain text");
		        Assert.assertTrue(response.contains("Single File Serving Sample 1"), "Content of response should contain 'Single File Serving Sample 1' from the file RequestHandlerIntegrationTestFile1.txt mapping.");
		        method.releaseConnection();
			}
    	}),
    	test_relative_classpath_file_mapping1(new EmptyRhIntTest() {
			public String getSimMappingAndAccess(ClientSideContext csc) {
				// is dependent on set_up_sim_access_for_file_tests
				return "<cctx-file cctx='/file/cp/relative/*' file='classpath:*' content-type='text/html'/>";
			}
			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> test_relative_classpath_file_mapping1");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/file/cp/relative/RequestHandlerIntegrationTestFile1.txt";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);

		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String response = method.getResponseBodyAsString().trim();
		        Assert.assertEquals(status, 200, "should have returned http 200 OK");
		        Header type = method.getResponseHeader("content-type");
		        Assert.assertEquals(type.getValue(), "text/html", "type should be text/html as defined in the mapping even though the extension of the file indicates just plain text");
		        Assert.assertTrue(response.contains("Single File Serving Sample 1"), "Content of response should contain 'Single File Serving Sample 1' from the file RequestHandlerIntegrationTestFile1.txt mapping.");
		        method.releaseConnection();
			}
    	}),
    	test_relative_classpath_file_mapping2(new EmptyRhIntTest() {
			public String getSimMappingAndAccess(ClientSideContext csc) {
				return ""; // uses config from test_relative_classpath_file_mapping1
			}
			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> test_relative_classpath_file_mapping2");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/file/cp/relative/RequestHandlerIntegrationTestFile2.txt";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);

		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        String response = method.getResponseBodyAsString().trim();
		        Assert.assertEquals(status, 200, "should have returned http 200 OK");
		        Header type = method.getResponseHeader("content-type");
		        Assert.assertEquals(type.getValue(), "text/html", "type should be text/html as defined in the mapping even though the extension of the file indicates just plain text");
		        Assert.assertTrue(response.contains("Single File Serving Sample 2"), "Content of response should contain 'Single File Serving Sample 2' from the file RequestHandlerIntegrationTestFile2.txt mapping.");
		        method.releaseConnection();
			}
    	}),
    	test_relative_classpath_file_mapping3(new EmptyRhIntTest() {
			public String getSimMappingAndAccess(ClientSideContext csc) {
				return ""; // uses config from test_relative_classpath_file_mapping1
			}
			public void runTest(ClientSideContext csc) throws Exception {
		        System.out.println("----> test_relative_classpath_file_mapping3");
		        String uri = "http://local.lds.org:" + csc.sitePort + "/file/cp/relative/non-existent-file.txt";
		        HttpClient client = new HttpClient();

		        HostConfiguration hcfg = new HostConfiguration();
		        hcfg.setProxy("127.0.0.1", csc.sitePort);
		        client.setHostConfiguration(hcfg);

		        HttpMethod method = new GetMethod(uri);

		        method.setFollowRedirects(false);
		        int status = client.executeMethod(method);
		        Assert.assertEquals(status, 404, "should have returned http 404 OK");
		        method.releaseConnection();
			}
    	});
    	// TODO

    	/**
    	 * The test implementation.
    	 */
    	private RhIntTest impl;

		RhTest(RhIntTest test) {
    		this.impl = test;
    	}
    }
    
    /**
     * App entry point if we want to run the back-end server standalone for some
     * testing.
     * 
     * @param args
     * @throws IOException
     * @throws InterruptedException
     */
    public static void main(String[] args) throws IOException, InterruptedException {
        new RequestHandlerIntegrationTest().setUpTestServer();
        while (true) {
            Thread.sleep(3000);
        }
    }
    
    private void setUpTestServer() throws IOException {
        // get socket of server emulator
        final ServerSocket sss = new ServerSocket();
        sss.setReuseAddress(true);
        sss.bind(null);
        cctx.serverPort = sss.getLocalPort();
        System.out.println("RequestHandlerIntegrationTest server-port = " + cctx.serverPort);

        // now start server to spool back responses to various requests
        server = new Thread() {
            @Override
            public void run() {
                try {
                    while (true) {
                        Socket sock = sss.accept();
                        InputStream is = sock.getInputStream();
                        String input = null;
                        try {
                            input = TestUtilities.readAllHttpHeaders(is);
                        } catch(Exception e) {
                            System.out.println("---> test server encountered exception reading stream listening for next connection.");
                            e.printStackTrace();
                            continue;
                        }
                        OutputStream out = sock.getOutputStream();
                        boolean alreadyHandled = false;
                        
                        ServerSideContext ssctx = new ServerSideContext(input, input.toLowerCase());
                        
                        for(RhTest test : RhTest.values()) {
                        	if (test.impl.appliesTo(ssctx)) {
                                System.out.println();
                                System.out.println("*** test server detected request: " + test.name());
                                System.out.println("--- received ---");
                                System.out.println(input);
                                if (test.impl instanceof RhIntPlusTest) {
                                	((RhIntPlusTest) test.impl).handleServerResponse(ssctx.envelope, ssctx.envelopeLC, out);
                                	alreadyHandled = true;
                                	break;
                                }
                                // else, drop to server-side approach
                                test.impl.handleServerSide(ssctx);
                                
                                if (ssctx.answer == null && ssctx.output == null && ssctx.fullOutputByteSet == null) {
                                	System.out.println("Server-side of Test " + test.name() + " failed to handle request...");
                                    ssctx.output =
                                            "HTTP/1.1 500 Internal Server Error" + RequestHandler.CRLF
                                            + "Content-length: 0" + RequestHandler.CRLF;
                                }
                                if (ssctx.answer != null) {
                                    ssctx.output =
                                            "HTTP/1.1 200 OK" + RequestHandler.CRLF
                                            + "Content-type: text/plain" + RequestHandler.CRLF
                                            + "Content-length: " + ssctx.answer.toCharArray().length + RequestHandler.CRLF
                                            + RequestHandler.CRLF
                                            + ssctx.answer;
                                    ssctx.output += RequestHandler.CRLF + RequestHandler.CRLF;
                                }
                                if (ssctx.output != null) {
                                	ssctx.fullOutputByteSet = new ByteArrayOutputStream();
                                    
                                    // add header/body termination indicators.
                                	ssctx.output += RequestHandler.CRLF + RequestHandler.CRLF;
                                    ssctx.fullOutputByteSet.write(ssctx.output.getBytes());
                                }
                                System.out.println();
                                System.out.println("--- returned ---");
                                System.out.println(ssctx.output);
                            	out.write(ssctx.fullOutputByteSet.toByteArray());
                                out.flush();
                                is.close();
                                out.close();
                            	alreadyHandled = true;
                        	}
                        }
                        String req = null;
                        String output = null;
                        String answer = null;
                        //String hostHdrLC = HeaderDef.Host.getNameWithColon().toLowerCase();
                        // TODO: remove this service? is any test using it???
                        if (input.contains("/slow/no/content/length/")) {
                            System.out.println();
                            System.out.println("*** test server detected request: " + req);
                            System.out.println("--- received ---");
                            System.out.println(input);

                            output = "HTTP/1.1 200 Not Found" + RequestHandler.CRLF
                                + "Content-Type: text/html; charset=iso-8859-1" + RequestHandler.CRLF
                                + "Server: test-harness" + RequestHandler.CRLF
                                + RequestHandler.CRLF + RequestHandler.CRLF
                                + "<html><head>\r\n" 
                                + "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\"/>\r\n" 
                                + "<title>Really slow content</title>\r\n" 
                                + "</head>\r\n";
                            out.write(output.getBytes());
                            out.flush();
                            System.out.println("--- returned ---");
                            System.out.println(output);
                            System.out.println("---> simulating slow connection by waiting 5s...");
                            Thread.sleep(5000);
                            output = "<body><h2>Really slow content</h2>\r\n" 
                                + "<p>Content served with no content-length and a wait time.</p>\r\n" 
                                + "<br/></body></html>";
                            System.out.println(output);
                            out.write(output.getBytes());
                            out.flush();
                            is.close();
                            out.close();
                            alreadyHandled = true;
                        }
                        else {
                            req = "UNEXPECTED";
                            output =
                                "HTTP/1.1 500 Internal Server Error due to unexpected request" + RequestHandler.CRLF;
                        }

						/*
						 * alreadyHandled == http response already sent and
						 * streams are closed
						 * 
						 * output == null means only body chars have been
						 * provided via the answer variable and envelope needs to
						 * be generated
						 * 
						 * output != null means full header and body response
						 * characters reside in output variable ready for 
						 * terminating and sending
						 * 
						 */
                        if (! alreadyHandled) {
                            if (output == null) {
                                output =
                                    "HTTP/1.1 200 OK" + RequestHandler.CRLF
                                    + "Content-type: text/plain" + RequestHandler.CRLF
                                    + "Content-length: " + answer.toCharArray().length + RequestHandler.CRLF
                                    + RequestHandler.CRLF
                                    + answer;
                            }

                            System.out.println();
                            System.out.println("*** test server detected request: " + req);
                            System.out.println("--- received ---");
                            System.out.println(input);
                            System.out.println("--- returned ---");
                            System.out.println(output);

                            // add header/body termination indicators.
                            output += RequestHandler.CRLF + RequestHandler.CRLF;

                            out.write(output.getBytes());
                            out.flush();
                            is.close();
                            out.close();
                        }
                    }
                } catch (Exception e) {
                    System.out.println("Server test thread incurred Exception, exiting.");
                    e.printStackTrace();
                }

                if (sss != null && sss.isBound()) {
                    try {
                        sss.close();
                    }
                    catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        server.start();
    }

    @BeforeClass
    public void setUpSimulator () throws Exception {
        // first clear any config residue
        Config cfg = new Config();

        // find a free port on which nothing is listening
        ServerSocket portFinder = new ServerSocket();
        portFinder.setReuseAddress(true);
        portFinder.bind(null);
        cctx = new ClientSideContext();
        cctx.freePort = portFinder.getLocalPort();
        try {
            portFinder.close();
        }
        catch(Exception e) {
            System.out.println("Exception releasing server port for use as bad gateway test " + e);
        }

        // spin up the backend test server fronted by the simulator
        this.setUpTestServer();
        
        // now set up the shim to verify various handling characteristics
        URL filePath = RequestHandlerIntegrationTest.class.getClassLoader().getResource("RhTestConfig.xml");
        URL filePath2 = RequestHandlerIntegrationTest.class.getClassLoader().getResource("RhTestConfig2.xml");
        URL filePath3 = RequestHandlerIntegrationTest.class.getClassLoader().getResource("RhTestConfig3.xml");
        System.getProperties().remove("non-existent-sys-prop");
        String xml = ""
        	+ "<?file-alias policy-src-xml=\"" + filePath.getPath().substring(1).replace("/", "\\") + "\"?>"
        	+ "<?file-alias policy-src-xml2=\"" + filePath2.getPath().substring(1).replace("/", "\\") + "\"?>"
        	+ "<?file-alias policy-src-xml3=\"" + filePath2.getPath().substring(1).replace("/", "\\") + "\"?>"
        	+ "<?system-alias usr-src-xml=non-existent-sys-prop default="
            + "\""
            + " <users>"
            + "  <user name='ngiwb1' pwd='password1'/>"
            + "  <user name='ngiwb2'>"
            + "   <att name='apps' value='aaa'/>"
            + "   <att name='apps' value='bbb'/>"
            + "   <att name='apps' value='ccc'/>"
            + "   <att name='preferredname'      value='" + MULTI_BYTE_CHARS_TEXT + "'/>"
            + "   <att name='givenname'          value='Jay Admin'/>"
            + "   <att name='preferredlanguage'  value='eng'/>"
            + "   <att name='preferred-name'     value='" + MULTI_BYTE_CHARS_TEXT + "'/>"
            + "   <att name='given-name'         value='Jay Admin'/>"
            + "   <att name='preferred-language' value='eng'/>"
            + "   <att name='preferred_name'     value='" + MULTI_BYTE_CHARS_TEXT + "'/>"
            + "   <att name='given_name'         value='Jay Admin'/>"
            + "   <att name='preferred_language' value='eng'/>"
            + "   <att name='att-1' value='val1'/>"
            + "   <att name='att-2' value='val2-1'/>"
            + "   <att name='att-2' value='val2-2'/>"
            + "  </user>"
            + " </users>"
        	+ "\"?>"
            + "<config console-port='auto' proxy-port='auto'>"
            + " <console-recording sso='true' rest='true' max-entries='100' enable-debug-logging='true' />"
            + " <sso-cookie name='lds-policy' domain='.lds.org' />"
            + " <proxy-timeout inboundMillis='400000' outboundMillis='400000'/>"
            + " <user-source type='xml'>xml={{usr-src-xml}}</user-source>"
            + " <sso-traffic strip-empty-headers='true'>"
            + "  <by-site scheme='http' host='local.lds.org' port='{{proxy-port}}'>"
            + "   <cctx-file cctx='/file/local/relative/*' file='*' content-type='text/plain'/>"
            + "   <cctx-file cctx='/file/local/fixed/*' file='sample-output.txt' content-type='text/plain'/>"
            + "   <cctx-file cctx='/file/cp/fixed/*' file='classpath:RequestHandlerIntegrationTestFile1.txt' content-type='text/html'/>"
            + "   <cctx-file cctx='/file/cp/relative/*' file='classpath:*' content-type='text/html'/>"
	        + "   <cctx-mapping thost='127.0.0.1' tport='" + cctx.serverPort + "' tpath='/*'>"
	        + "    <policy-source>xml={{policy-src-xml}}</policy-source>"
	        + "   </cctx-mapping>"
	        + "  </by-site>"
	        + "  <by-site scheme='http' host='local2.lds.org' port='{{proxy-port}}'>"
	        + "   <cctx-mapping thost='127.0.0.1' tport='" + cctx.serverPort + "' tpath='/*' preserve-host='false'>"
	        + "    <policy-source>xml={{policy-src-xml2}}</policy-source>"
	        + "   </cctx-mapping>"
            + "  </by-site>"
            + "  <by-site scheme='http' host='local3.lds.org' port='{{proxy-port}}'>"
	        + "   <cctx-mapping thost='127.0.0.1' tport='" + cctx.serverPort + "' tpath='/*' host-header='host.lds.org:2445'>"
	        + "    <policy-source>xml={{policy-src-xml3}}</policy-source>"
	        + "   </cctx-mapping>"
            + "  </by-site>"
            + " </sso-traffic>"
            + "</config>";
        service = Service.getService("string:" + xml);
        service.start();
        cctx.sitePort = Config.getInstance().getProxyPort();
        System.out.println(); // to leave a gap before test output.


    }

    @AfterClass
    public void tearDownSimulator() throws Exception {
        service.stop();
        server.interrupt();
    }

    //////////////// tests with config and/or server-side functionality start here

    @Test
    public void test_verify_serviceUrl_signIn_signOut_injected() throws Exception {
    	RhTest.verify_serviceUrl_signIn_signOut_injected.impl.runTest(cctx);
    }

    @Test
    public void test_404_payload_with_content_length_is_passed_through() throws Exception {
    	RhTest.resp_code_404_test_wcl.impl.runTest(cctx);
    }

    @Test
    public void test_404_payload_without_content_length_is_passed_through() throws Exception {
    	RhTest.resp_code_404_test_ncl.impl.runTest(cctx);
    }

    @Test
    public void test_local_relative_file_mapping() throws Exception {
    	RhTest.test_local_relative_file_mapping.impl.runTest(cctx);
    }

    @Test
    public void test_local_fixed_file_mapping() throws Exception {
    	RhTest.test_local_fixed_file_mapping.impl.runTest(cctx);
    }

    @Test
    public void test_fixed_classpath_file_mapping() throws Exception {
    	RhTest.test_fixed_classpath_file_mapping.impl.runTest(cctx);
    }

    @Test
    public void test_relative_classpath_file_mapping1() throws Exception {
    	RhTest.test_relative_classpath_file_mapping1.impl.runTest(cctx);
    }

    @Test
    public void test_relative_classpath_file_mapping2() throws Exception {
    	RhTest.test_relative_classpath_file_mapping2.impl.runTest(cctx);
    }

    @Test
    public void test_relative_classpath_file_mapping3() throws Exception {
    	RhTest.test_relative_classpath_file_mapping3.impl.runTest(cctx);
    }

    @Test
    public void test_preserve_host() throws Exception {
    	RhTest.preserve_host_test.impl.runTest(cctx);
    }

    @Test
    public void test_verify_cctx_injected() throws Exception {
    	RhTest.verify_cctx_injected_test.impl.runTest(cctx);
    }
    
    @Test
    public void wamulat_60_test() throws Exception {
    	RhTest.wamulat_60_test.impl.runTest(cctx);
    }
    
    @Test
    public void wamulat_56_test() throws Exception {
    	RhTest.wamulat_56_test.impl.runTest(cctx);
    }
    
    @Test
    public void test_wamulat_35_pipe_char_in_url_passes_to_app() throws Exception {
    	RhTest.wamulat_35_pipe_char_test.impl.runTest(cctx);
    }
    
    @Test
    public void test_wamulat_35_pipe_char_in_full_reqLnUrl_passes_to_app() throws Exception {
    	RhTest.wamulat_35_pipe_char_absltReqLn_test.impl.runTest(cctx);
    }
    
    @Test
    public void test_dont_preserve_host() throws Exception {
    	RhTest.no_preserve_host_test.impl.runTest(cctx);
    }
    
    @Test
    public void profile_header_injection_test() throws Exception {
    	RhTest.profile_header_injection_test.impl.runTest(cctx);
    }

    @Test
    public void fixed_header_injection_test() throws Exception {
    	RhTest.fixed_header_injection_test.impl.runTest(cctx);
    }

    @Test
    public void test_wamulat_48() throws Exception {
    	RhTest.wamulat_48_test.impl.runTest(cctx);
    }

    @Test
    public void test_host_header() throws Exception {
    	RhTest.host_header_test.impl.runTest(cctx);
    }
    @Test
    public void test_restricted_with_no_session_redir_2_signin() throws Exception {
    	RhTest.restricted_test_redird.impl.runTest(cctx);
    }

    @Test
    public void test_restricted_with_good_session_proxied() throws Exception {
    	RhTest.restricted_test.impl.runTest(cctx);
    }

    @Test
    public void test_restricted_with_good_session_not_cond_403() throws Exception {
    	RhTest.conditional_test.impl.runTest(cctx);
    }

    @Test
    public void test_bad_response_startline_no_space() throws Exception {
    	RhTest.bad_startline_message.impl.runTest(cctx);
    }

    @Test
    public void test_bad_request_startline_no_space() throws Exception {
    	RhTest.bad_request_startline_no_space.impl.runTest(cctx);
    }

    @Test
    public void test_bad_gateway_when_connecting() throws Exception {
    	// TODO
    	RhTest.bad_gateway_message.impl.runTest(cctx);
    }

    @Test
    public void test_bad_gateway_empty_message() throws Exception {
    	RhTest.bad_gateway_empty_message.impl.runTest(cctx);
    }

    @Test
    public void test_bad_gateway_message() throws Exception {
    	RhTest.bad_gateway_message.impl.runTest(cctx);
    }

    /////////////// tests that do not contribute to simulator config nor have
    /////////////// server-side behavior below 

    @Test
    public void test_forward_proxying_blocked() throws HttpException, IOException {
        Config cfg = Config.getInstance();
        System.out.println("----> test_forward_proxying_blocked");
        String uri = "http://unmapped-host.lds.org:" + cctx.sitePort + "/any/path/";
        HttpClient client = new HttpClient();

        HostConfiguration hcfg = new HostConfiguration();
        hcfg.setProxy("127.0.0.1", cctx.sitePort);
        client.setHostConfiguration(hcfg);

        HttpMethod method = new GetMethod(uri);
        method.setFollowRedirects(false);
        int status = client.executeMethod(method);
        String resp = method.getResponseBodyAsString();
        if (status != 501 && resp != null) {
            System.out.println(resp);
        }
        Assert.assertEquals(status, 501, "should have returned http 501");
        method.releaseConnection();
    }

    @Test
    public void test_restricted_with_expired_session_redir_2_signin() throws HttpException, IOException {
        Config cfg = Config.getInstance();
        String token = TestUtilities.authenticateUser("ngiwb1", cfg.getConsolePort(), "local.lds.org");
        cfg.getSessionManager().terminateAllSessions();
        System.out.println("----> test_restricted_with_expired_session_redir_2_signin");
        String uri = "http://local.lds.org:" + cctx.sitePort + "/restricted/path/";
        HttpClient client = new HttpClient();

        HostConfiguration hcfg = new HostConfiguration();
        hcfg.setProxy("127.0.0.1", cctx.sitePort);
        client.setHostConfiguration(hcfg);

        HttpMethod method = new GetMethod(uri);
        method.setRequestHeader(new Header("cookie", cfg.getCookieName() + "=" + token));
        method.setFollowRedirects(false);
        int status = client.executeMethod(method);
        Assert.assertEquals(status, 302, "should have returned http 302");
        Header loc = method.getResponseHeader("location");
        String location = loc.getValue();
        String loginPg = Config.getInstance().getLoginPage()
                + "?goto=" + URLEncoder.encode(uri, "utf-8");
        Assert.assertEquals(location, loginPg,
                "redirect location was wrong.");
        method.releaseConnection();
    }

    @Test
    public void test_empty_bad_request() throws HttpException, IOException {
        System.out.println("----> test_empty_bad_request");
        Socket soc = new Socket("127.0.0.1", cctx.sitePort);
        soc.setSoTimeout(2000); // force the input stream to wait 2 seconds for response
        OutputStream out = soc.getOutputStream();
        InputStream in = soc.getInputStream();
        out.write(RequestHandler.CRLF.getBytes());
        out.flush();
        String resp = TestUtilities.readAllHttpHeaders(in);
        //No need to assert.  here as long as an exception isn't thrown we're good. WAMULAT-53
        //Assert.assertTrue(resp.startsWith("HTTP/1.1 404 Bad Request"), "Response should have started with 'HTTP/1.1 404 Bad Request' but was: '" + resp + "'");
    }

    @Test
    public void test_client_request_timeout() throws HttpException, IOException {
        Config cfg = Config.getInstance();
        int old = cfg.getProxyInboundSoTimeout();
        try {
        System.out.println("----> test_client_request_timeout");
        // get SoTimeout for proxy client inputstream and set really low for this test
        System.out.println("setting proxy inbound timeout to 1");
        cfg.setProxyInboundSoTimeout(1); // 1 millisecond
        Socket soc = new Socket("127.0.0.1", cctx.sitePort);
        InputStream in = soc.getInputStream();
        String resp = null;
        resp = TestUtilities.readAllHttpHeaders(in);
        Assert.assertTrue(resp.startsWith("HTTP/1.1 408 Request Timeout"), "Response should have started with 'HTTP/1.1 408 Request Timeout' but was: '" + resp + "'");
        } finally {
            // stick old value back in
            System.out.println("restoring proxy inbound timeout to " + old);
            cfg.setProxyInboundSoTimeout(old);
        }
    }

}
